import { resolve } from "path";
import { existsSync, mkdirSync, writeFileSync } from "fs";
import { glob } from "glob";
import { analyzeController, ControllerInfo, MethodInfo, ParameterInfo } from "./analyzer";

// ---------- Public types ----------

export interface GenerateHooksOptions {
  /** API global prefix, e.g. "/api" */
  prefix?: string;
  /** Source directory to scan for *.controller.ts files */
  srcDir?: string;
  /** Output directory for generated hooks file */
  outputDir?: string;
  /** Shared package name for type imports, e.g. "@nene/shared" */
  sharedPkg?: string;
}

// ---------- Main entry ----------

export async function generateHooks(
  cwd: string,
  options: GenerateHooksOptions = {}
): Promise<void> {
  const {
    prefix = "/api",
    srcDir = "./src",
    outputDir = "./src/hooks",
    sharedPkg = "@nene/shared",
  } = options;

  const srcPath = resolve(cwd, srcDir);
  const hooksDir = resolve(cwd, outputDir);

  // Create hooks directory if it doesn't exist
  if (!existsSync(hooksDir)) {
    mkdirSync(hooksDir, { recursive: true });
  }

  // Check if source directory exists
  if (!existsSync(srcPath)) {
    writeFileSync(
      resolve(hooksDir, "index.ts"),
      emptyHooksFile()
    );
    console.log(`  Source directory not found: ${srcPath}`);
    return;
  }

  // Scan for all *.controller.ts files recursively
  const controllerFiles = await glob("**/*.controller.ts", {
    cwd: srcPath,
    absolute: true,
    ignore: ["**/node_modules/**", "**/dist/**"],
  });

  if (controllerFiles.length === 0) {
    writeFileSync(
      resolve(hooksDir, "index.ts"),
      emptyHooksFile()
    );
    console.log("  No controller files found.");
    return;
  }

  console.log(`  Found ${controllerFiles.length} controller(s):`);

  // Analyze all controllers and collect hooks + type imports
  const allHooks: string[] = [];
  const collectedTypes = new Set<string>();

  for (const file of controllerFiles) {
    const controllerInfo = analyzeController(file);
    if (!controllerInfo) continue;

    console.log(`    - ${controllerInfo.name} (${controllerInfo.methods.length} methods)`);

    const hooks = generateControllerHooks(controllerInfo, prefix, collectedTypes);
    if (hooks) {
      allHooks.push(hooks);
    }
  }

  // Build imports
  const imports: string[] = [
    '"use client";',
    "",
    'import { useQuery, useMutation } from "nene/react";',
  ];

  // Add shared type imports if any were collected
  if (collectedTypes.size > 0) {
    const typeNames = Array.from(collectedTypes).sort().join(", ");
    imports.push(`import type { ${typeNames} } from "${sharedPkg}";`);
  }

  imports.push("");

  // Write output
  const content = [
    "// Auto-generated by nene.js",
    "// DO NOT EDIT - This file is regenerated when controllers change",
    "",
    ...imports,
    ...allHooks,
    "", // trailing newline
  ].join("\n");

  const outputPath = resolve(hooksDir, "index.ts");
  writeFileSync(outputPath, content);
  console.log(`\n  Generated hooks at: ${outputPath}`);
}

// ---------- Hook generation ----------

function generateControllerHooks(
  controller: ControllerInfo,
  prefix: string,
  collectedTypes: Set<string>
): string {
  const hooks: string[] = [];

  for (const method of controller.methods) {
    const hook = generateMethodHook(controller, method, prefix, collectedTypes);
    hooks.push(hook);
  }

  return hooks.join("\n\n");
}

function generateMethodHook(
  controller: ControllerInfo,
  method: MethodInfo,
  prefix: string,
  collectedTypes: Set<string>
): string {
  const hookName = generateHookName(controller.name, method.name, method.httpMethod);
  const fullPath = joinPaths(prefix, controller.path, method.path);

  // Separate path params from other params
  const pathParams = method.parameters.filter((p) => p.type === "param");
  const queryParams = method.parameters.filter((p) => p.type === "query");
  const bodyParam = method.parameters.find((p) => p.type === "body");

  // Build parameter type
  const paramTypes: string[] = [];

  if (pathParams.length > 0) {
    const pathParamTypes = pathParams
      .map((p) => `${p.key || p.name}: ${resolveType(p.tsType, collectedTypes)}`)
      .join("; ");
    paramTypes.push(pathParamTypes);
  }

  if (queryParams.length > 0) {
    const queryParamTypes = queryParams
      .map((p) => `${p.key || p.name}?: ${resolveType(p.tsType, collectedTypes)}`)
      .join("; ");
    paramTypes.push(queryParamTypes);
  }

  const hasParams = pathParams.length > 0 || queryParams.length > 0;
  const paramsType = hasParams ? `{ ${paramTypes.join("; ")} }` : "void";

  if (method.httpMethod === "GET") {
    return generateQueryHook(
      hookName,
      fullPath,
      paramsType,
      pathParams,
      queryParams,
      resolveType(method.returnType, collectedTypes)
    );
  } else {
    const bodyType = bodyParam
      ? resolveType(bodyParam.tsType, collectedTypes)
      : "unknown";
    return generateMutationHook(
      hookName,
      fullPath,
      method.httpMethod,
      bodyType,
      resolveType(method.returnType, collectedTypes)
    );
  }
}

function generateQueryHook(
  hookName: string,
  path: string,
  paramsType: string,
  pathParams: ParameterInfo[],
  queryParams: ParameterInfo[],
  returnType: string
): string {
  const hasParams = paramsType !== "void";
  const paramArg = hasParams ? `params: ${paramsType}` : "";

  // Build URL with path params
  let urlTemplate = path;
  for (const param of pathParams) {
    const key = param.key || param.name;
    urlTemplate = urlTemplate.replace(`:${key}`, `\${params.${key}}`);
  }

  const hasQueryParams = queryParams.length > 0;

  if (hasQueryParams) {
    const querySetters = queryParams
      .map((q) => {
        const key = q.key || q.name;
        return `      if (params.${key} !== undefined) searchParams.set("${key}", String(params.${key}));`;
      })
      .join("\n");

    return `export function ${hookName}(${paramArg}) {
  return useQuery<${returnType}>(
    ["${hookName}"${hasParams ? ", params" : ""}],
    async () => {
      const searchParams = new URLSearchParams();
${querySetters}
      const queryString = searchParams.toString();
      const url = \`${urlTemplate}\${queryString ? "?" + queryString : ""}\`;
      const response = await fetch(url);
      if (!response.ok) throw new Error("Request failed");
      return response.json();
    }
  );
}`;
  }

  return `export function ${hookName}(${paramArg}) {
  return useQuery<${returnType}>(
    ["${hookName}"${hasParams ? ", params" : ""}],
    async () => {
      const response = await fetch(\`${urlTemplate}\`);
      if (!response.ok) throw new Error("Request failed");
      return response.json();
    }
  );
}`;
}

function generateMutationHook(
  hookName: string,
  path: string,
  httpMethod: string,
  bodyType: string,
  returnType: string
): string {
  return `export function ${hookName}() {
  return useMutation<${returnType}, ${bodyType}>(
    async (data) => {
      const response = await fetch("${path}", {
        method: "${httpMethod}",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      if (!response.ok) throw new Error("Request failed");
      return response.json();
    }
  );
}`;
}

// ---------- Type resolution ----------

const PRIMITIVE_TYPES = new Set([
  "string", "number", "boolean", "null", "undefined",
  "void", "any", "unknown", "never", "object",
]);

/**
 * Resolve a type string for use in generated hooks.
 * - Primitives are kept as-is.
 * - Complex types (DTO names like CreateWaitlistDto) are preserved
 *   and added to collectedTypes so they get imported from @nene/shared.
 */
function resolveType(type: string, collectedTypes: Set<string>): string {
  if (!type || type === "unknown") return "unknown";

  // Remove Promise wrapper
  const promiseMatch = type.match(/^Promise<(.+)>$/);
  if (promiseMatch) {
    type = promiseMatch[1];
  }

  // Primitives pass through
  if (PRIMITIVE_TYPES.has(type)) return type;

  // Primitive arrays pass through
  const arrayMatch = type.match(/^(\w+)\[\]$/);
  if (arrayMatch && PRIMITIVE_TYPES.has(arrayMatch[1])) return type;

  // Named types that look like DTO/interface names (PascalCase identifiers)
  if (/^[A-Z]\w+$/.test(type)) {
    collectedTypes.add(type);
    return type;
  }

  // Named type arrays
  const namedArrayMatch = type.match(/^([A-Z]\w+)\[\]$/);
  if (namedArrayMatch) {
    collectedTypes.add(namedArrayMatch[1]);
    return type;
  }

  // For complex inline types (object literals, unions, etc.), fall back to unknown
  return "unknown";
}

// ---------- Naming helpers ----------

function generateHookName(
  controllerName: string,
  methodName: string,
  _httpMethod: string
): string {
  // Capitalize method name
  const capitalizedMethod =
    methodName.charAt(0).toUpperCase() + methodName.slice(1);

  return `use${capitalizedMethod}`;
}

function joinPaths(...paths: string[]): string {
  return (
    "/" +
    paths
      .map((p) => p.replace(/^\/|\/$/g, ""))
      .filter(Boolean)
      .join("/")
  );
}

// ---------- Helpers ----------

function emptyHooksFile(): string {
  return [
    "// Auto-generated by nene.js",
    "// No controllers found. Hooks will appear here when you create controllers.",
    "export {};",
    "",
  ].join("\n");
}
