import { resolve, basename } from "path";
import { existsSync, mkdirSync, writeFileSync } from "fs";
import { glob } from "glob";
import { analyzeController, ControllerInfo, MethodInfo } from "./analyzer";

export async function generateHooks(cwd: string): Promise<void> {
  const controllersDir = resolve(cwd, "src/controllers");
  const hooksDir = resolve(cwd, "src/hooks");

  // Create hooks directory if it doesn't exist
  if (!existsSync(hooksDir)) {
    mkdirSync(hooksDir, { recursive: true });
  }

  // Check if controllers directory exists
  if (!existsSync(controllersDir)) {
    writeFileSync(
      resolve(hooksDir, "index.ts"),
      "// Auto-generated hooks will appear here when you create controllers\nexport {};\n"
    );
    return;
  }

  // Find all controller files
  const controllerFiles = await glob("**/*.controller.ts", {
    cwd: controllersDir,
    absolute: true,
  });

  if (controllerFiles.length === 0) {
    writeFileSync(
      resolve(hooksDir, "index.ts"),
      "// Auto-generated hooks will appear here when you create controllers\nexport {};\n"
    );
    return;
  }

  // Analyze and generate hooks for each controller
  const allHooks: string[] = [];
  const imports: string[] = [
    '"use client";',
    "",
    'import { useQuery, useMutation } from "nene/react";',
    "",
  ];

  for (const file of controllerFiles) {
    const controllerInfo = analyzeController(file);
    if (controllerInfo) {
      const hooks = generateControllerHooks(controllerInfo);
      allHooks.push(hooks);
    }
  }

  const content = [
    "// Auto-generated by nene.js",
    "// DO NOT EDIT - This file is regenerated when controllers change",
    "",
    ...imports,
    ...allHooks,
  ].join("\n");

  writeFileSync(resolve(hooksDir, "index.ts"), content);
}

function generateControllerHooks(controller: ControllerInfo): string {
  const hooks: string[] = [];

  for (const method of controller.methods) {
    const hook = generateMethodHook(controller, method);
    hooks.push(hook);
  }

  return hooks.join("\n\n");
}

function generateMethodHook(
  controller: ControllerInfo,
  method: MethodInfo
): string {
  const hookName = generateHookName(
    controller.name,
    method.name,
    method.httpMethod
  );
  const fullPath = joinPaths(controller.path, method.path);

  // Separate path params from other params
  const pathParams = method.parameters.filter((p) => p.type === "param");
  const queryParams = method.parameters.filter((p) => p.type === "query");
  const bodyParam = method.parameters.find((p) => p.type === "body");

  // Build parameter type
  const paramTypes: string[] = [];

  if (pathParams.length > 0) {
    const pathParamTypes = pathParams
      .map((p) => `${p.key || p.name}: ${p.tsType}`)
      .join("; ");
    paramTypes.push(pathParamTypes);
  }

  if (queryParams.length > 0) {
    const queryParamTypes = queryParams
      .map((p) => `${p.key || p.name}?: ${p.tsType}`)
      .join("; ");
    paramTypes.push(queryParamTypes);
  }

  const hasParams = pathParams.length > 0 || queryParams.length > 0;
  const paramsType = hasParams ? `{ ${paramTypes.join("; ")} }` : "void";

  if (method.httpMethod === "GET") {
    return generateQueryHook(
      hookName,
      fullPath,
      paramsType,
      pathParams,
      queryParams,
      method.returnType
    );
  } else {
    return generateMutationHook(
      hookName,
      fullPath,
      method.httpMethod,
      bodyParam?.tsType || "unknown",
      method.returnType
    );
  }
}

function generateQueryHook(
  hookName: string,
  path: string,
  paramsType: string,
  pathParams: { key?: string; name: string }[],
  queryParams: { key?: string; name: string }[],
  returnType: string
): string {
  const hasParams = paramsType !== "void";
  const paramArg = hasParams ? `params: ${paramsType}` : "";

  // Build URL with path params
  let urlBuilder = `"${path}"`;
  for (const param of pathParams) {
    const key = param.key || param.name;
    urlBuilder = urlBuilder.replace(`:${key}`, `\${params.${key}}`);
  }

  // Add query params
  const hasQueryParams = queryParams.length > 0;

  // Simplify return type - use unknown for complex types that aren't available in hooks file
  const safeReturnType = simplifyType(returnType);

  return `export function ${hookName}(${paramArg}) {
  return useQuery<${safeReturnType}>(
    ["${hookName}"${hasParams ? ", params" : ""}],
    async () => {
      ${
        hasQueryParams
          ? `const searchParams = new URLSearchParams();
      ${queryParams
        .map(
          (q) =>
            `if (params.${q.key || q.name} !== undefined) searchParams.set("${
              q.key || q.name
            }", String(params.${q.key || q.name}));`
        )
        .join("\n      ")}
      const queryString = searchParams.toString();
      const url = \`${urlBuilder.replace(
        /"/g,
        ""
      )}\${queryString ? "?" + queryString : ""}\`;`
          : `const url = \`${urlBuilder.replace(/"/g, "")}\`;`
      }
      const response = await fetch(url);
      if (!response.ok) throw new Error("Request failed");
      return response.json();
    }
  );
}`;
}

function generateMutationHook(
  hookName: string,
  path: string,
  httpMethod: string,
  bodyType: string,
  returnType: string
): string {
  // Simplify types - use unknown for complex types that aren't available in hooks file
  const safeReturnType = simplifyType(returnType);
  const safeBodyType = simplifyType(bodyType);

  return `export function ${hookName}() {
  return useMutation<${safeReturnType}, ${safeBodyType}>(
    async (data) => {
      const response = await fetch("${path}", {
        method: "${httpMethod}",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      if (!response.ok) throw new Error("Request failed");
      return response.json();
    }
  );
}`;
}

// Simplify complex types to avoid referencing types not available in hooks file
function simplifyType(type: string): string {
  if (!type || type === "unknown") return "unknown";

  // Remove Promise wrapper
  const promiseMatch = type.match(/^Promise<(.+)>$/);
  if (promiseMatch) {
    type = promiseMatch[1];
  }

  // If it's a primitive type, keep it
  const primitives = [
    "string",
    "number",
    "boolean",
    "null",
    "undefined",
    "void",
    "any",
    "unknown",
  ];
  if (primitives.includes(type)) return type;

  // If it's an array of primitives, keep it
  const arrayMatch = type.match(/^(\w+)\[\]$/);
  if (arrayMatch && primitives.includes(arrayMatch[1])) return type;

  // For complex types (interfaces, custom types), use unknown
  // This avoids referencing types that aren't imported
  return "unknown";
}

function generateHookName(
  controllerName: string,
  methodName: string,
  httpMethod: string
): string {
  // Remove "Controller" suffix
  const baseName = controllerName.replace(/Controller$/, "");

  // Capitalize method name
  const capitalizedMethod =
    methodName.charAt(0).toUpperCase() + methodName.slice(1);

  // For GET, use "use" prefix (query)
  // For other methods, use "use" + action name (mutation)
  return `use${capitalizedMethod}`;
}

function joinPaths(...paths: string[]): string {
  return paths
    .map((p) => p.replace(/^\/|\/$/g, ""))
    .filter(Boolean)
    .join("/")
    .replace(/^/, "/");
}
