import { resolve } from "path";
import { existsSync, mkdirSync, writeFileSync, readdirSync } from "fs";
import { glob } from "glob";
import { analyzeController, ControllerInfo } from "./analyzer";

export async function generateRoutes(cwd: string): Promise<void> {
  const controllersDir = resolve(cwd, "src/controllers");
  const apiDir = resolve(cwd, "src/app/api/[...nene]");

  // Check if controllers directory exists
  if (!existsSync(controllersDir)) {
    return;
  }

  // Find all controller files
  const controllerFiles = await glob("**/*.controller.ts", {
    cwd: controllersDir,
    absolute: true,
  });

  if (controllerFiles.length === 0) {
    return;
  }

  // Create catch-all API route directory
  if (!existsSync(apiDir)) {
    mkdirSync(apiDir, { recursive: true });
  }

  // Analyze all controllers
  const controllers: ControllerInfo[] = [];
  const importStatements: string[] = [];

  for (const file of controllerFiles) {
    const info = analyzeController(file);
    if (info) {
      controllers.push(info);
      // Generate import path using @/ alias (which maps to ./src/)
      // file: /path/to/project/src/controllers/foo.controller.ts
      // we want: @/controllers/foo.controller
      const srcDir = resolve(cwd, "src");
      const relativePath = file.replace(srcDir, "").replace(/\.ts$/, "");
      importStatements.push(`import { ${info.name} } from "@${relativePath}";`);
    }
  }

  // Generate the route handler
  const routeContent = generateRouteHandler(controllers, importStatements);
  writeFileSync(resolve(apiDir, "route.ts"), routeContent);
}

function generateRouteHandler(
  controllers: ControllerInfo[],
  imports: string[]
): string {
  const controllerRegistrations = controllers
    .map((c) => `  registerController(${c.name});`)
    .join("\n");

  return `// Auto-generated by nene.js
// DO NOT EDIT - This file is regenerated when controllers change

import { NextRequest, NextResponse } from "next/server";
import "reflect-metadata";
import { 
  getControllerMetadata, 
  getRouteMetadata, 
  getParamMetadata,
  container,
  runWithContext,
  createContext
} from "nene";

${imports.join("\n")}

// Controller registry
const controllers: Map<string, { instance: unknown; routes: Map<string, { method: string; handler: Function; params: unknown[] }> }> = new Map();

function registerController(Controller: new () => unknown) {
  const metadata = getControllerMetadata(Controller);
  if (!metadata) return;

  const instance = container.resolve(Controller as new (...args: unknown[]) => unknown);
  const routes = new Map();

  // Get all method names
  const prototype = Controller.prototype;
  const methodNames = Object.getOwnPropertyNames(prototype).filter(
    name => name !== "constructor"
  );

  for (const methodName of methodNames) {
    const routeMeta = getRouteMetadata(prototype, methodName);
    if (!routeMeta) continue;

    const paramMeta = getParamMetadata(prototype, methodName);
    const fullPath = joinPaths(metadata.path, routeMeta.path);
    const key = \`\${routeMeta.method}:\${fullPath}\`;

    routes.set(key, {
      method: routeMeta.method,
      handler: (instance as Record<string, Function>)[methodName].bind(instance),
      params: paramMeta,
    });
  }

  controllers.set(metadata.path, { instance, routes });
}

function joinPaths(...paths: string[]): string {
  return "/" + paths.map(p => p.replace(/^\\/|\\/$/g, "")).filter(Boolean).join("/");
}

// Register all controllers
${controllerRegistrations}

async function handleRequest(request: NextRequest, method: string) {
  const url = new URL(request.url);
  const pathname = url.pathname;

  // Find matching route
  for (const [basePath, controller] of controllers) {
    for (const [key, route] of controller.routes) {
      if (!key.startsWith(method + ":")) continue;
      
      const routePath = key.split(":")[1];
      const match = matchPath(routePath, pathname);
      
      if (match) {
        try {
          const context = createContext(request);
          
          return await runWithContext(context, async () => {
            // Extract parameters
            const args = await extractParams(request, route.params, match.params);
            const result = await route.handler(...args);
            return NextResponse.json(result);
          });
        } catch (error) {
          console.error("Route handler error:", error);
          return NextResponse.json(
            { error: error instanceof Error ? error.message : "Internal server error" },
            { status: 500 }
          );
        }
      }
    }
  }

  return NextResponse.json({ error: "Not found" }, { status: 404 });
}

function matchPath(pattern: string, pathname: string): { params: Record<string, string> } | null {
  const patternParts = pattern.split("/").filter(Boolean);
  const pathParts = pathname.split("/").filter(Boolean);

  if (patternParts.length !== pathParts.length) return null;

  const params: Record<string, string> = {};

  for (let i = 0; i < patternParts.length; i++) {
    const patternPart = patternParts[i];
    const pathPart = pathParts[i];

    if (patternPart.startsWith(":")) {
      params[patternPart.slice(1)] = pathPart;
    } else if (patternPart !== pathPart) {
      return null;
    }
  }

  return { params };
}

async function extractParams(
  request: NextRequest,
  paramMeta: unknown[],
  pathParams: Record<string, string>
): Promise<unknown[]> {
  const args: unknown[] = [];
  const url = new URL(request.url);
  
  let body: unknown = null;
  if (["POST", "PUT", "PATCH"].includes(request.method)) {
    try {
      body = await request.json();
    } catch {
      body = null;
    }
  }

  for (const meta of paramMeta as Array<{ type: string; key?: string; index: number }>) {
    let value: unknown;
    
    switch (meta.type) {
      case "body":
        value = meta.key && body ? (body as Record<string, unknown>)[meta.key] : body;
        break;
      case "param":
        value = meta.key ? pathParams[meta.key] : pathParams;
        break;
      case "query":
        value = meta.key ? url.searchParams.get(meta.key) : Object.fromEntries(url.searchParams);
        break;
      case "headers":
        value = meta.key ? request.headers.get(meta.key) : Object.fromEntries(request.headers);
        break;
    }

    args[meta.index] = value;
  }

  return args;
}

export async function GET(request: NextRequest) {
  return handleRequest(request, "GET");
}

export async function POST(request: NextRequest) {
  return handleRequest(request, "POST");
}

export async function PUT(request: NextRequest) {
  return handleRequest(request, "PUT");
}

export async function PATCH(request: NextRequest) {
  return handleRequest(request, "PATCH");
}

export async function DELETE(request: NextRequest) {
  return handleRequest(request, "DELETE");
}
`;
}
